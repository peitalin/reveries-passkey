# COSE Public Key to NEAR Ed25519 Public Key Derivation

This document outlines the key derivation logic used to derive a NEAR-compatible Ed25519 public key from a WebAuthn authenticator (passkey). WebAuthn public keys are in COSE (CBOR Object Signing and Encryption) format.

## Objective

To have a unique and deterministically derived Ed25519 public key that can be registered on the NEAR blockchain (e.g., in a signer smart contract) and associated with a user's passkey. This allows the passkey to authorize actions related to this derived NEAR public key.

## Process Overview

The server receives the raw `credentialPublicKey` (a COSE key) from the `@simplewebauthn/server` library after a successful passkey registration or authentication. This key is then parsed and processed.

1.  **Decode COSE Key**:
    *   The raw `credentialPublicKey` (an `ArrayBuffer` or `Buffer`) is decoded using a CBOR parser (e.g., `cbor-x`).
    *   This results in a JavaScript object representing the COSE key structure.

2.  **Identify Key Type and Algorithm**:
    *   The COSE key object is inspected to determine its properties:
        *   `kty` (Key Type, label `1`): Identifies the type of key (e.g., `2` for EC2 - Elliptic Curve, `1` for OKP - Octet Key Pair).
        *   `alg` (Algorithm, label `3`): Identifies the algorithm used (e.g., `-7` for ES256/P-256, `-8` for EdDSA/Ed25519).

3.  **Derivation Logic**:

    *   **Case 1: COSE Key is already Ed25519 (OKP, alg: -8)**
        *   This is less common for browser-generated passkeys but is handled if encountered.
        *   The COSE key parameters for Ed25519 (kty: `1`, alg: `-8`, crv: `6` for Ed25519) are checked.
        *   The raw public key bytes (typically 32 bytes) are extracted directly from the `x` coordinate field (label `-2`) of the COSE key.
        *   A NEAR `PublicKey` object (type `KeyType.ED25519`) is created using these raw bytes.
        *   This public key is then converted to its string representation (e.g., `ed25519:Base58EncodedKey`).
        *   **Example Snippet (`server/src/index.ts` context):**
            ```typescript
            // const coseKeyObject = decode(credentialPublicKey);
            // const kty = coseKeyObject[1];
            // const alg = coseKeyObject[3];
            // if (kty === 1 && alg === -8) { // OKP, EdDSA
            //   const xCoord = coseKeyObject[-2]; // x-coordinate (raw Ed25519 public key)
            //   if (xCoord instanceof Uint8Array && xCoord.length === 32) {
            //     const nearEd25519Pk = new PublicKey({ keyType: KeyType.ED25519, data: Buffer.from(xCoord) });
            //     nearPublicKeyToStore = nearEd25519Pk.toString();
            //   }
            // }
            ```

    *   **Case 2: COSE Key is P-256 (EC2, alg: -7)**
        *   This is the most common case for passkeys generated by browsers and security keys.
        *   The COSE key parameters for P-256 (kty: `2`, alg: `-7`, crv: `1` for P-256 curve) are checked.
        *   The `x` coordinate (label `-2`) and `y` coordinate (label `-3`) of the P-256 public key are extracted. These are typically 32-byte `Uint8Array`s.
        *   **Seed Generation**:
            1.  The byte arrays of `x` and `y` coordinates are concatenated (e.g., `x` followed by `y`).
            2.  This concatenated buffer is hashed using SHA-256. The resulting 32-byte hash serves as a deterministic seed.
        *   **Ed25519 Key Pair Derivation**:
            1.  The 32-byte seed is Base58 encoded.
            2.  An Ed25519 key pair is generated using `new KeyPairEd25519(secretKeyBase58)` from `@near-js/crypto`, where `secretKeyBase58` is the Base58 encoded seed. This seed effectively acts as the private key for the new Ed25519 pair.
            3.  The public key from this newly derived Ed25519 key pair is obtained.
            4.  This public key is converted to its string representation (e.g., `ed25519:Base58EncodedKey`). This is the `derivedNearPublicKey`.
        *   **Example Snippet (`server/src/index.ts` context):**
            ```typescript
            // const coseKeyObject = decode(credentialPublicKey);
            // // ... kty, alg, crv, x, y extraction ...
            // if (crv === 1 && x instanceof Uint8Array && y instanceof Uint8Array) { // P-256
            //   const hash = createHash('sha256');
            //   hash.update(Buffer.from(x));
            //   hash.update(Buffer.from(y));
            //   const seedBytes = hash.digest(); // 32-byte Buffer
            //
            //   const secretKeyBase58 = bs58.encode(seedBytes.subarray(0, 32));
            //   const nearKeyPair = new KeyPairEd25519(secretKeyBase58);
            //
            //   derivedNearPublicKeyString = nearKeyPair.getPublicKey().toString();
            //   nearPublicKeyToStore = derivedNearPublicKeyString;
            // }
            ```

4.  **Storage**:
    *   The resulting `derivedNearPublicKey` (string) is stored in the server's database (e.g., in the `authenticators` table) alongside other passkey credential information. This links the passkey to its corresponding NEAR public key. These details can be threshold encrypted for additional security and key recovery measures.

## Security and Determinism

*   **Determinism**: The derivation process (especially for P-256) is designed to be deterministic. Given the same P-256 public key, the same Ed25519 public key will always be derived. This is crucial for consistently identifying the associated NEAR key upon subsequent passkey authentications.
*   **No Private Key Exposure**: The user's actual passkey private key (P-256 private key) never leaves their authenticator and is not known to the server.
*   **Derived Private Key**: While the server can derive the Ed25519 private key corresponding to the `derivedNearPublicKey` (since it generates the seed), this derived private key is not directly used by the server to sign transactions in the signer smart contract model. Instead, the `derivedNearPublicKey` acts as an identifier that the smart contract recognizes as authorized by the user's passkey. The server (relayer) uses its own separate NEAR account to pay for gas and submit transactions to the smart contract.

This derived key is then used in conjunction with the signer smart contract to enable passkey-based transaction authorization on the NEAR network.